name: Deploy with Helm

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  AWS_REGION: us-west-1
  ECR_REPOSITORY: portfolio-app
  EKS_CLUSTER_NAME: portfolio-cluster

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    name: Deploy to EKS
    runs-on: ubuntu-latest

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: arn:aws:iam::537124942860:role/github-actions-role
        aws-region: us-west-1
        audience: sts.amazonaws.com
        role-session-name: GitHubActions

    - name: Verify AWS Authentication
      run: |
        echo "Verifying AWS Authentication..."
        aws sts get-caller-identity
        echo "Listing EKS clusters..."
        aws eks list-clusters

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Setup kubectl
      run: |
        echo "Installing kubectl..."
        curl -LO "https://dl.k8s.io/release/v1.28.1/bin/linux/amd64/kubectl"
        chmod +x kubectl
        sudo mv kubectl /usr/local/bin/
        kubectl version --client

    - name: Setup Helm
      run: |
        echo "Installing Helm..."
        curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
        chmod 700 get_helm.sh
        ./get_helm.sh
        helm version

    - name: Simple EKS Authentication
      run: |
        echo "Setting up EKS authentication with minimal approach..."
        
        # Get cluster info
        echo "Getting cluster endpoint..."
        CLUSTER_ENDPOINT=$(aws eks describe-cluster --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }} --query "cluster.endpoint" --output text)
        echo "Cluster endpoint: $CLUSTER_ENDPOINT"
        
        # Get certificate data
        echo "Getting cluster certificate..."
        CERTIFICATE_DATA=$(aws eks describe-cluster --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }} --query "cluster.certificateAuthority.data" --output text)
        
        # Create basic kubeconfig
        echo "Creating kubeconfig file..."
        mkdir -p $HOME/.kube
        cat > $HOME/.kube/config << EOF
        apiVersion: v1
        kind: Config
        clusters:
        - cluster:
            server: ${CLUSTER_ENDPOINT}
            certificate-authority-data: ${CERTIFICATE_DATA}
          name: kubernetes
        contexts:
        - context:
            cluster: kubernetes
            user: aws
          name: aws
        current-context: aws
        users:
        - name: aws
          user:
            exec:
              apiVersion: client.authentication.k8s.io/v1beta1
              command: aws
              args:
              - eks
              - get-token
              - --cluster-name
              - ${{ env.EKS_CLUSTER_NAME }}
              - --region
              - ${{ env.AWS_REGION }}
        EOF
        
        echo "Testing kubeconfig..."
        kubectl config view
        
        echo "Testing connection to cluster..."
        kubectl cluster-info
        
        echo "Testing node access..."
        kubectl get nodes

    - name: Manage aws-auth ConfigMap
      run: |
        echo "Creating or updating aws-auth ConfigMap..."
        
        # Check if aws-auth ConfigMap exists
        if kubectl get configmap aws-auth -n kube-system &>/dev/null; then
          echo "aws-auth ConfigMap exists - downloading current version"
          # Get current ConfigMap
          kubectl get configmap aws-auth -n kube-system -o yaml > aws-auth-current.yaml
          
          # Check if our role is already in the ConfigMap
          if grep -q "537124942860:role/github-actions-role" aws-auth-current.yaml; then
            echo "Role already exists in ConfigMap - no update needed"
          else
            echo "Adding role to existing ConfigMap"
            # Add our role to the ConfigMap
            cat > aws-auth-patch.yaml << EOF
        apiVersion: v1
        kind: ConfigMap
        metadata:
          name: aws-auth
          namespace: kube-system
        data:
          mapRoles: |
            - rolearn: arn:aws:iam::537124942860:role/github-actions-role
              username: github-actions
              groups:
                - system:masters
        EOF
            
            # Apply the updated ConfigMap
            kubectl apply -f aws-auth-patch.yaml
          fi
        else
          echo "aws-auth ConfigMap does not exist - creating new ConfigMap"
          # Create new ConfigMap
          cat > aws-auth-new.yaml << EOF
        apiVersion: v1
        kind: ConfigMap
        metadata:
          name: aws-auth
          namespace: kube-system
        data:
          mapRoles: |
            - rolearn: arn:aws:iam::537124942860:role/github-actions-role
              username: github-actions
              groups:
                - system:masters
        EOF
          
          # Apply the new ConfigMap
          kubectl apply -f aws-auth-new.yaml
        fi
        
        echo "Verifying aws-auth ConfigMap..."
        kubectl get configmap aws-auth -n kube-system -o yaml
        
        echo "Testing permissions..."
        kubectl auth can-i '*' '*'

    - name: Debug Environment
      run: |
        echo "Using EKS Cluster: ${{ env.EKS_CLUSTER_NAME }}"
        echo "AWS Region: ${{ env.AWS_REGION }}"
        echo "Current directory: $(pwd)"
        echo "Helm chart directory:"
        ls -la ./kubernetes/helm/app || echo "Helm chart directory not found"
        
    - name: Deploy with Helm
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        echo "============ DEPLOYMENT DEBUG INFO ============"
        echo "Image registry from ECR login step: $ECR_REGISTRY"
        echo "Image tag: $IMAGE_TAG"
        echo "Using release name: portfolio-app"
        
        # Verify ECR registry value
        if [ -z "$ECR_REGISTRY" ]; then
          echo "ERROR: ECR_REGISTRY is empty! Printing all environment variables for debugging:"
          env | sort
          echo "Attempting to retrieve ECR registry directly from AWS..."
          MANUAL_ECR_REGISTRY=$(aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} --query 'repositories[0].repositoryUri' --output text | sed 's/\/.*$//')
          echo "Manually retrieved ECR registry: $MANUAL_ECR_REGISTRY"
          ECR_REGISTRY=$MANUAL_ECR_REGISTRY
        fi
        
        # Set repository with fallback
        if [ -n "$ECR_REGISTRY" ]; then
          FULL_REPO="${ECR_REGISTRY}/${{ env.ECR_REPOSITORY }}"
        else
          echo "WARNING: Using incomplete repository path as fallback"
          FULL_REPO="${{ env.ECR_REPOSITORY }}"
        fi
        
        echo "Full image repository path: $FULL_REPO"
        echo "============================================"
        
        # Verify Kubernetes connection one more time
        echo "Verifying Kubernetes connectivity..."
        kubectl get nodes
        
        # Create prod namespace if it doesn't exist
        echo "Checking/creating prod namespace..."
        kubectl get namespace prod || kubectl create namespace prod
        
        # Deploy with Helm
        echo "Starting Helm deployment..."
        helm upgrade --install portfolio-app ./kubernetes/helm/app \
          --set image.repository=$FULL_REPO \
          --set image.tag=$IMAGE_TAG \
          --namespace prod
        
        # Verify deployment
        echo "Verifying deployment..."
        kubectl get pods -n prod
        kubectl rollout status deployment/portfolio-app -n prod --timeout=60s || true
        
    - name: Notify Slack
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ job.status }}
        fields: repo,message,commit,author,action,eventName,ref,workflow,job,took
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      if: always()